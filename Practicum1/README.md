# Практикум №1. Регулярные выражения

## [Задание. Вариант 19](https://github.com/alexander89116/flt_mipt/blob/master/Practicum1/Practicum1_tasks.pdf)

Дано регулярное выражение и буква *x*. Найти максимальное *k*, такое что в *L* есть слова, закачивающиеся на *x^k*

## [Алгоритм](https://github.com/alexander89116/flt_mipt/blob/master/Practicum1/main.cpp)

Нам дано регулярное выражение в обратной опльской записи и символ. Будем поддерживать три стека **min_length**, **max_suffix_length** (суффикс максимальной длины из данного символа) и **is_only_char** (*true*, если существует непустая строка состоящая только из данного символа). На каждом шаге в зависимости от символа обновляем состояния стеков. Если регулярное выражение корректное, то для любого символа операции в стеках есть необходимое количество аргументов и в конце обработки выражения в стеке должен лежать один элемент, отвечающий за всё выражение.

Ассимптотика **O(N)**, где *N* - длина регулярного выражения в обратной польской записи. Линейность алгоритма получается из-за использования стека и константном количестве операций на нём на каждом шаге алгоритма

## [Запуск тестов](https://github.com/alexander89116/flt_mipt/blob/master/Practicum1/run_tests.sh)
```
bash run_tests.sh
```
Всего 9 тестов. Результаты тестирования выглядят так (для первых двух):
```
Test 0:
ab+c.aba.*.bac.+.+* b
1
Test result: Ok

Test 1:
acb..bab.c.*.ab.ba.+.+*a. b
0
Test result: Ok
```
